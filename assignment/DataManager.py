import pandas as pd
import random
import math
import numpy as np
import ImageManager as im
import constants as cn

"""	Shuffle two lists """
def shuffle_lists(l1, l2):
	"""
	l1, l2:	lists to be shuffled
	
	return:	the two lists shuffled
	"""

	z = list(zip(l1, l2))
	random.shuffle(z)
	a, b = zip(*z)

	return list(a), list(b)


"""	Load training and test dataframes """
def load_training_test_DF(train_path, test_path):
	"""
	train_path:	path used for the training set
	test_path:	path used for the test set

	return: 	training set and test set as dataframes
	"""

	df_training = pd.read_csv(train_path)
	df_test = pd.read_csv(test_path)

	return df_training, df_test


""" create a list of "samples" pairs of images to be trained """
def lists_generator(df, items_per_class, samples, train_test):
	"""
	df:				dataframe where to load the data from
	samples:		number of images pairs to be trained	
	items_per_class:number of items belonging to the same class inside the dataframe
	train_test:		integer representing whether to generate training (0) or test set (1)

	return:		X_list:	representing a list of samples compared images (1 pair belonging to the 
						same class, N-1 pairs belonging to different classes) as features (1D array)
				y_list:	representing a list of binary values (0 or 1) whether (1) or not (0) 
						the paired images belong to the same class			
	"""

	X_list = []
	y_list = []

	count_same = 0
	count_different = 0

	#	if test set generator, divide the number of samples by 4
	if(train_test == 1):
		samples = int(samples/4)

	for i in range(0, samples):
		#	randomly choose a class among all of the classes inside the dataframe
		rnd = np.random.choice(range(0, len(df)))
		img_class = int(math.modf(rnd/items_per_class)[1])

		#	randomly choose an image within that class
		rnd1 = np.random.choice(range(img_class*items_per_class, (img_class*items_per_class)+items_per_class))		

		#	random number to choose whether or not the other image should belong to the same (1) or different class (0)
		rnd_same_different = np.random.choice([0, 1])

		#	randomly choose another image belonging to the same class as only one example
		if(rnd_same_different == 1):			
			rnd2 = np.random.choice(range(img_class*items_per_class, (img_class*items_per_class)+items_per_class))			
			y_list.append(1)
			count_same += 1

		#	randomly choose a class that is different from the one previously computed
		else:
			rnd2 = np.random.choice(np.setdiff1d(range(0, len(df)), range(img_class*items_per_class, (img_class*items_per_class)+items_per_class)))									
			y_list.append(0)
			count_different += 1

		#	load the images
		img1 = im.load_image(df.iloc[rnd1]["path"])		
		img2 = im.load_image(df.iloc[rnd2]["path"])

		#	add in X_list the image generated by overlapping the two images
		X_list.append([im.process_images(img1, img2)])

	if(train_test == 0):
		print("%d same and %d different pairs of images for training set" % (count_same, count_different))
	else:
		print("%d same and %d different pairs of images for test set" % (count_same, count_different))

	return X_list, y_list	


""" Create training and test set """
def train_test_set_generator(samples):
	"""
	samples:	number of samples for training and test set

	return:		X_train, y_train, X_test, y_test
	"""

	df_training, df_test = load_training_test_DF(cn.train_dataset_name, cn.test_dataset_name)		

	X_train, y_train = lists_generator(df=df_training, items_per_class=cn.training_samples, samples=samples, train_test=0)
	X_test, y_test = lists_generator(df=df_test, items_per_class=cn.test_samples, samples=samples, train_test=1)

	X_train, y_train = shuffle_lists(X_train, y_train)
	X_test, y_test = shuffle_lists(X_test, y_test)

	return X_train, y_train, X_test, y_test


""" generate lists for predictions in N-way One Shot Learning """
def N_way_one_shot_learning(N, df, items_per_class):
	"""
	N:		N-1 different classes, only one example
	df:		dataframe used to load the data
	items_per_class:number of items belonging to the same class inside the dataframe
	
	return:	feature_list:	list of N different classes with only one example
			target_list:	list of correct answers (0=different, 1=same)
	"""

	feature_list = []
	target_list = []	
	
	#	randomly choose a class among all of the classes inside the dataframe
	rnd = np.random.choice(range(0, len(df)))
	img_class = int(math.modf(rnd/items_per_class)[1])

	#	randomly choose an image within that class
	rnd1 = np.random.choice(range(img_class*items_per_class, (img_class*items_per_class)+items_per_class), replace=False)
	#	randomly choose another image belonging to the same class as only one example
	rnd2 = np.random.choice(range(img_class*items_per_class, (img_class*items_per_class)+items_per_class), replace=False)

	#	load the images
	img1 = im.load_image(df.iloc[rnd1]["path"])
	img2 = im.load_image(df.iloc[rnd2]["path"])

	#	add in X_list the image generated by overlapping the two images belonging to the same class
	feature_list.append([im.process_images(img1, img2)])	
	target_list.append(1)		

	#	add other N-1 different images belonging to different classes
	for j in range(0, N-1):
		#	randomly choose a class that is different from the one previously computed
		rnd3 = np.random.choice(np.setdiff1d(range(0, len(df)), range(img_class*items_per_class, (img_class*items_per_class)+items_per_class)), replace=False)
		
		#	load the image
		img3 = im.load_image(df.iloc[rnd3]["path"])

		#	add the image generated by overlapping the two images belonging to different classes
		feature_list.append([im.process_images(img1, img3)])		
		target_list.append(0)

	return feature_list, target_list
